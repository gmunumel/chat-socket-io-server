'use strict';

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _mockSocket = require('mock-socket');

var _server = require('../server');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// const Server   = require('mock-socket').Server;
// const SocketIO = require('mock-socket').SocketIO;

// const GoServer = require('../server').GoServer;

_ava2.default.cb('Server Unit Test', t => {
  // it('basic test', (done) => {
  const mockServer = new _mockSocket.Server('http://localhost:8080');
  mockServer.on('connection', () => {
    mockServer.emit('messages', 'test message 1');
    mockServer.emit('messages', 'test message 2');
  });

  // This step is very important! It tells our server app to use the mocked
  // websocket object instead of the native one. The great thing
  // about this is that our actual code did not need to change and
  // thus is agnostic to how we test it.

  window.io = _mockSocket.SocketIO;

  // Now when Go Server tries to do io() or io.connect()
  // it will use MockSocketIO object
  var app = new _server.GoServer();

  setTimeout(() => {
    const messageLen = app.messages.length;
    // assert.equal(messageLen, 2, '2 messages where sent from the server');
    t.is(messageLen, 2);
    mockServer.stop(done);
    t.end();
  }, 100);
  // });
});

// test.cb('a socket can emit to a room', t => {
//   const server = new Server('ws://roomy');
//   const socketFoo = SocketIO('ws://roomy');
//   const socketBar = SocketIO('ws://roomy');

//   var redis = require('redis-mock'),
//         client = redis.createClient();

//   socketFoo.on('connect', () => {
//     socketFoo.join('room');
//   });
//   socketFoo.on('room-talk', () => {
//     t.true(true);
//     server.close();
//     t.end();
//   });

//   socketBar.on('connect', () => {
//     socketBar.join('room');
//     socketBar.to('room').emit('room-talk');
//   });
// });
//# sourceMappingURL=../node_modules/.cache/ava/3e70938040013ba68ea2134730e915f3.js.map